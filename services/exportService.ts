import { ProcessedSocialContent, HashtagMetrics, PlatformMetrics } from './socialDataProcessors';
import html2canvas from 'html2canvas';
import jsPDF from 'jspdf';

export interface ExportOptions {
  format: 'csv' | 'json' | 'xlsx' | 'pdf';
  includeCharts?: boolean;
  includeMetadata?: boolean;
  dateRange?: {
    start: string;
    end: string;
  };
  filters?: {
    platforms?: string[];
    sentiment?: string[];
    engagement?: string;
  };
}

export interface ExportData {
  content?: ProcessedSocialContent[];
  hashtags?: HashtagMetrics[];
  platforms?: PlatformMetrics[];
  metadata?: {
    exportDate: string;
    totalRecords: number;
    filters: any;
    generatedBy: string;
    section?: string;
    generatedAt?: string;
  };
}

export interface ExportFormat {
  format: 'pdf' | 'csv' | 'xls';
  label: string;
}

class ExportService {
  // Get available export options based on data section
  getExportOptions(section: string): ExportFormat[] {
    const baseOptions: ExportFormat[] = [
      { format: 'csv', label: 'CSV Spreadsheet' },
      { format: 'xls', label: 'Excel Workbook' }
    ];

    // Add PDF option for sections that support visual export
    const pdfSupportedSections = [
      'dashboard',
      'reports', 
      'News Blog Monitoring',
      'Dashboard Analytics',
      'Social Listening',
      'Keywords Management',
      'YouTube Search',
      'Social Analytics',
      'Competitor Analysis',
      'Hashtag Tracker',
      'Trending Mentions',
      'AI Chatbot'
    ];

    if (pdfSupportedSections.includes(section)) {
      baseOptions.unshift({ format: 'pdf', label: 'PDF Report' });
    }

    return baseOptions;
  }

  // Export data to CSV format
  async exportToCSV(data: ExportData, options?: ExportOptions): Promise<Blob> {
    let csvContent = '';
    
    // Add metadata if requested
    if (options?.includeMetadata && data.metadata) {
      csvContent += `# Export Metadata\n`;
      csvContent += `Export Date,${data.metadata.exportDate}\n`;
      csvContent += `Total Records,${data.metadata.totalRecords}\n`;
      csvContent += `Generated By,${data.metadata.generatedBy}\n`;
      csvContent += `\n`;
    }

    // Export content data
    if (data.content && data.content.length > 0) {
      csvContent += `# Social Media Content\n`;
      csvContent += `ID,Platform,Content,Author,Username,Followers,Verified,Likes,Shares,Comments,Views,Total Engagement,Hashtags,Mentions,Published At,URL,Media Type,Sentiment Score,Sentiment Label,Reach,Viral,Language,Location\n`;
      
      data.content.forEach(item => {
        const row = [
          item.id,
          item.platform,
          `"${item.content.replace(/"/g, '""')}"`, // Escape quotes
          `"${item.author.name.replace(/"/g, '""')}"`,
          item.author.username,
          item.author.followers || 0,
          item.author.verified ? 'Yes' : 'No',
          item.engagement.likes,
          item.engagement.shares,
          item.engagement.comments,
          item.engagement.views,
          item.engagement.total,
          `"${item.hashtags.join('; ')}"`,
          `"${item.mentions.join('; ')}"`,
          item.publishedAt,
          item.url,
          item.media.type,
          item.sentiment.score,
          item.sentiment.label,
          item.reach.estimated,
          item.reach.viral ? 'Yes' : 'No',
          item.language,
          item.location || ''
        ];
        csvContent += row.join(',') + '\n';
      });
      csvContent += '\n';
    }

    // Export hashtag data
    if (data.hashtags && data.hashtags.length > 0) {
      csvContent += `# Hashtag Metrics\n`;
      csvContent += `Hashtag,Mentions,Platforms,Total Engagement,Likes,Shares,Comments,Views,Positive %,Negative %,Neutral %,Trend Direction,Trend Change,Reach,Viral,Last Seen\n`;
      
      data.hashtags.forEach(hashtag => {
        const row = [
          hashtag.hashtag,
          hashtag.count,
          `"${hashtag.platforms.join('; ')}"`,
          hashtag.engagement.total,
          hashtag.engagement.likes,
          hashtag.engagement.shares,
          hashtag.engagement.comments,
          hashtag.engagement.views,
          hashtag.sentiment.positive,
          hashtag.sentiment.negative,
          hashtag.sentiment.neutral,
          hashtag.trend.direction,
          hashtag.trend.change,
          hashtag.reach.estimated,
          hashtag.reach.viral ? 'Yes' : 'No',
          hashtag.lastSeen
        ];
        csvContent += row.join(',') + '\n';
      });
      csvContent += '\n';
    }

    // Export platform data
    if (data.platforms && data.platforms.length > 0) {
      csvContent += `# Platform Metrics\n`;
      csvContent += `Platform,Total Content,Total Engagement,Avg Engagement,Engagement Rate,Reach,Positive %,Negative %,Neutral %\n`;
      
      data.platforms.forEach(platform => {
        const row = [
          platform.platform,
          platform.totalContent,
          platform.totalEngagement,
          platform.avgEngagement.toFixed(2),
          platform.engagementRate.toFixed(2),
          platform.reach,
          platform.sentiment.positive,
          platform.sentiment.negative,
          platform.sentiment.neutral
        ];
        csvContent += row.join(',') + '\n';
      });
    }

    return new Blob([csvContent], { type: 'text/csv;charset=utf-8;' });
  }

  // Export data to JSON format
  async exportToJSON(data: ExportData, options: ExportOptions): Promise<Blob> {
    const exportData = {
      ...data,
      exportOptions: options,
      generatedAt: new Date().toISOString()
    };

    const jsonContent = JSON.stringify(exportData, null, 2);
    return new Blob([jsonContent], { type: 'application/json' });
  }

  // Export data to PDF format
  async exportToPDF(data: ExportData, targetElement?: HTMLElement): Promise<void> {
    try {
      let canvas: HTMLCanvasElement;
      
      if (targetElement) {
        // Store original styles
        const originalClasses = targetElement.className;
        const originalWidth = targetElement.style.width;
        const originalMaxWidth = targetElement.style.maxWidth;
        
        // Apply PDF export mode class temporarily
        targetElement.className += ' pdfExportMode';
        
        // Set a specific width for PDF export to ensure full width usage
        const targetWidth = 700; // Target width for PDF content (fits better on page)
        targetElement.style.width = `${targetWidth}px`;
        targetElement.style.maxWidth = 'none';
        
        // Wait for styles to apply and UI to stabilize
        await new Promise(resolve => setTimeout(resolve, 150));
        
        // Capture the specific element
        canvas = await html2canvas(targetElement, {
          scale: 2, // Higher scale for better quality
          useCORS: true,
          allowTaint: true,
          backgroundColor: '#ffffff',
          logging: false,
          width: targetWidth, // Use target width
          height: targetElement.scrollHeight,
          scrollX: 0,
          scrollY: 0,
          windowWidth: targetWidth, // Use target width
          windowHeight: targetElement.scrollHeight
        });
        
        // Restore original classes and styles
        targetElement.className = originalClasses;
        targetElement.style.width = originalWidth;
        targetElement.style.maxWidth = originalMaxWidth;
      } else {
        // Create a PDF from data (fallback)
        const pdf = new jsPDF('p', 'mm', 'a4');
        const pageWidth = pdf.internal.pageSize.getWidth();
        const pageHeight = pdf.internal.pageSize.getHeight();
        
        // Add title
        pdf.setFontSize(20);
        pdf.text('Social Listening Report', pageWidth / 2, 20, { align: 'center' });
        
        // Add metadata
        if (data.metadata) {
          pdf.setFontSize(12);
          pdf.text(`Generated: ${new Date(data.metadata.generatedAt || Date.now()).toLocaleString()}`, 20, 40);
          pdf.text(`Total Records: ${data.metadata.totalRecords}`, 20, 50);
        }
        
        // Add content summary
        let yPosition = 70;
        pdf.setFontSize(14);
        pdf.text('Data Summary:', 20, yPosition);
        yPosition += 10;
        
        pdf.setFontSize(10);
        if (data.content && data.content.length > 0) {
          pdf.text(`• ${data.content.length} social media posts`, 20, yPosition);
          yPosition += 8;
        }
        if (data.hashtags && data.hashtags.length > 0) {
          pdf.text(`• ${data.hashtags.length} hashtag metrics`, 20, yPosition);
          yPosition += 8;
        }
        if (data.platforms && data.platforms.length > 0) {
          pdf.text(`• ${data.platforms.length} platform metrics`, 20, yPosition);
          yPosition += 8;
        }
        
        const filename = this.generateFilename(data, { format: 'pdf' });
        pdf.save(filename);
        return;
      }
      
      // Convert canvas to PDF
      const imgData = canvas.toDataURL('image/png');
      const pdf = new jsPDF('p', 'mm', 'a4');
      const pageWidth = pdf.internal.pageSize.getWidth();
      const pageHeight = pdf.internal.pageSize.getHeight();
      
      // Calculate dimensions to fit the image properly
      const imgWidth = canvas.width;
      const imgHeight = canvas.height;
      
      // Use full page width with minimal margin
      const margin = 5; // 5mm margin
      const availableWidth = pageWidth - (margin * 2);
      const availableHeight = pageHeight - (margin * 2);
      
      // Calculate scale to fit both width and height
      const widthRatio = availableWidth / imgWidth;
      const heightRatio = availableHeight / imgHeight;
      
      // Use the smaller ratio to ensure content fits on the page
      const scale = Math.min(widthRatio, heightRatio);
      
      const finalWidth = imgWidth * scale;
      const finalHeight = imgHeight * scale;
      
      // Check if content fits on one page
      if (finalHeight <= availableHeight) {
        // Single page - center horizontally and vertically
        const x = (pageWidth - finalWidth) / 2; // Center horizontally
        const y = Math.max(margin, (pageHeight - finalHeight) / 2);
        pdf.addImage(imgData, 'PNG', x, y, finalWidth, finalHeight);
      } else {
        // Multi-page - split content
        const pagesNeeded = Math.ceil(finalHeight / availableHeight);
        const imgHeightPerPage = imgHeight / pagesNeeded;
        
        for (let i = 0; i < pagesNeeded; i++) {
          if (i > 0) pdf.addPage();
          
          const sourceY = i * imgHeightPerPage;
          const sourceHeight = Math.min(imgHeightPerPage, imgHeight - sourceY);
          const scaledHeight = sourceHeight * scale;
          
          // Create a temporary canvas for this page
          const pageCanvas = document.createElement('canvas');
          const pageCtx = pageCanvas.getContext('2d');
          pageCanvas.width = imgWidth;
          pageCanvas.height = sourceHeight;
          
          // Draw the portion of the image for this page
          pageCtx?.drawImage(canvas, 0, sourceY, imgWidth, sourceHeight, 0, 0, imgWidth, sourceHeight);
          
          const pageImgData = pageCanvas.toDataURL('image/png');
          const x = (pageWidth - finalWidth) / 2; // Center horizontally
          const y = margin;
          
          pdf.addImage(pageImgData, 'PNG', x, y, finalWidth, scaledHeight);
        }
      }
      
      const filename = this.generateFilename(data, { format: 'pdf' });
      pdf.save(filename);
      
    } catch (error) {
      console.error('PDF export failed:', error);
      
      // Ensure we restore styles even if there's an error
      if (targetElement) {
        try {
          targetElement.className = targetElement.className.replace(' pdfExportMode', '');
          targetElement.style.width = '';
          targetElement.style.maxWidth = '';
        } catch (restoreError) {
          console.error('Error restoring element styles:', restoreError);
        }
      }
      
      // Fallback to CSV export
      try {
        const csvBlob = await this.exportToCSV(data, { 
          format: 'csv', 
          includeMetadata: true 
        });
        const filename = this.generateFilename(data, { format: 'csv' });
        this.downloadFile(csvBlob, filename);
        alert('PDF export failed. CSV file has been downloaded instead.');
      } catch (fallbackError) {
        console.error('Fallback export also failed:', fallbackError);
        alert('Export failed. Please try again.');
      }
    }
  }

  // Export data to XLS format
  async exportToXLS(data: ExportData): Promise<void> {
    // For now, we'll export as CSV and suggest Excel conversion
    // In a real implementation, you'd use a library like xlsx
    const csvBlob = await this.exportToCSV(data, { 
      format: 'csv', 
      includeMetadata: true 
    });
    const filename = this.generateFilename(data, { format: 'xlsx' });
    this.downloadFile(csvBlob, filename);
    
    // Show a message to the user
    alert('Excel export is not yet implemented. CSV file has been downloaded instead. You can open it in Excel and save as .xlsx format.');
  }

  // Main export function
  async exportData(data: ExportData, options: ExportOptions): Promise<Blob> {
    switch (options.format) {
      case 'csv':
        return this.exportToCSV(data, options);
      case 'json':
        return this.exportToJSON(data, options);
      default:
        throw new Error(`Unsupported export format: ${options.format}`);
    }
  }

  // Download file helper
  downloadFile(blob: Blob, filename: string): void {
    const url = window.URL.createObjectURL(blob);
    const link = document.createElement('a');
    link.href = url;
    link.download = filename;
    document.body.appendChild(link);
    link.click();
    document.body.removeChild(link);
    window.URL.revokeObjectURL(url);
  }

  // Generate filename based on data and options
  generateFilename(data: ExportData, options: ExportOptions): string {
    const timestamp = new Date().toISOString().split('T')[0];
    const dataType = data.content ? 'content' : data.hashtags ? 'hashtags' : 'platforms';
    const extension = options.format === 'xlsx' ? 'xls' : options.format;
    return `social-listening-${dataType}-${timestamp}.${extension}`;
  }
}

export const exportService = new ExportService();
